import math
import os

class RowFormats():
    def __init__(self):
        """This class identify the format of each rows in the record file.
        """        
        self.goldenLabelFormat = {'label': 0,
                                  'left-top': 1,
                                  'right-bottom': 2,
                                  'order': 3,
                                  'duration': 4,}
        
        self.inferenceResultFormat = {'result-label-name': 0,
                                      'inspect-left-top': 1,
                                      'inspect-right-bottom': 2,
                                      'order': 3,
                                      'duration': 4,
                                      'ok-ng': 5,
                                      'golden-position': 6,
                                      'confidence': 7}

        self.confirmedResultFormat = {'result-label-name': 0,
                                      'inspect-left-top': 1,
                                      'inspect-right-bottom': 2,
                                      'order': 3,
                                      'duration': 4,
                                      'ok-ng': 5,
                                      'golden-position': 6}

class ThresholdRecommander():
    def __init__(self, inferenceResultFolderPath, confirmedResultFolderPath, goldenLabelFilePath, objective='preventLeakage', thresholdScale=0.01):
        """This class execute the threshold generator logic for recommendation.

        Args:
            inferenceResultFolderPath (str): The path to a folder containing the inference results. These results are predictions generated by model you use.
            confirmedResultFolderPath (str): The path to a folder containing the confirmed results. These are the actual outcomes or ground truth for the recommendations.
            goldenLabelFilePath (str): The path to a file containing the golden labels. These are the ideal recommendations or target values for the model.
            objective (str, optional): A string specifying the objective of the threshold generation. The default value is 'preventLeakage', 
                                       'preventLeakage': Suggests that the goal is to minimize the number of leakage.
                                       'preventOverkill': Suggests that the goal is to minimize the number of overkill.
                                       'preventLeakage-scale': Suggests that the goal is to minimize the number of leakage with the recommand threshold multiply ( 1 + thresholdScale).
                                       'preventOverkill-scale': Suggests that the goal is to minimize the number of overkill with the recommand threshold multiply ( 1 - thresholdScale).
            thresholdScale (float, optional): A float representing the scale or step size used in the threshold generation process. It determines the granularity of the threshold search. Defaults to 0.01.
        """        
        self.rowFormat = RowFormats()
        self.goldenROIResultDatas = {}
        self.labelConfidenceDatas = {}
        self.labelConfidenceMaxMinDatas = {}
        self.inferenceResultFolderPath = inferenceResultFolderPath
        self.confirmedResultFolderPath = confirmedResultFolderPath
        self.goldenLabelFilePath = goldenLabelFilePath
        self.goldenLabelRowList = []
        self.__recommandThreshold = []
        self.objective = objective
        self.thresholdScale = thresholdScale

    @property
    def ROIThresholds(self):
        return self.__recommandThreshold

    def __parseData(self, filePath, delimiter=';'):
        rowsList = []
        if os.path.exists(filePath) == False:
            print(f"{filePath} does not exist.")
            return rowsList
        
        with open(filePath, 'r') as f:
            for line in f:
                fields = line.strip().split(delimiter)
                rowsList.append(fields)
        return rowsList

    def __findItem(self, rows, target):
        for item in rows:
            if target in item:
                return item
        return None

    def __appendDataIntoDictionary(self, dictionary, key, appendData):
        if key not in dictionary:
            dictionary[key] = []
        dictionary[key].append(appendData)     
    
    def merge_left_top_right_bottom_coordinate_str(self, left_top, right_bottom):
        left_top = left_top.replace(')', '').replace(' ', '')
        right_bottom = right_bottom.replace('(', '').replace(' ', '')
        return left_top + ',' + right_bottom

    def saparate_left_top_right_bottom_coordinate_str(self, left_top_right_bottom):
        left_top_right_bottom = left_top_right_bottom[1:-1]
        first_comma_index = left_top_right_bottom.index(',')
        second_comma_index = left_top_right_bottom.index(',', first_comma_index + 1)
        left_top = '(' + left_top_right_bottom[:second_comma_index] + ')'
        right_bottom = '(' + left_top_right_bottom[second_comma_index + 1:] + ')'
        return left_top, right_bottom
    
    def getGoldenLabelByCoordinate(self, left_top_right_bottom):
        left_top, right_bottom = self.saparate_left_top_right_bottom_coordinate_str(left_top_right_bottom)
        for row in self.goldenLabelRowList:
            if row[self.rowFormat.goldenLabelFormat['left-top']].replace(' ', '') == left_top and row[self.rowFormat.goldenLabelFormat['right-bottom']].replace(' ', '') == right_bottom:
                return row[self.rowFormat.goldenLabelFormat['label']]
        return 'Not-Found'

    def __isOK(self, str):
        return True if str.upper() == 'OK' else False

    def __parseThenMerge(self, inferenceResultFilePath, confirmedResultFilePath):
        # parse inference and confirmed result
        inferenceResultRows = self.__parseData(inferenceResultFilePath, ';')
        confirmedResultRows = self.__parseData(confirmedResultFilePath, ';')

        for confirmed_row in confirmedResultRows:
            goldenROIPosition = confirmed_row[self.rowFormat.confirmedResultFormat['golden-position']]
            inference_row = self.__findItem(inferenceResultRows, goldenROIPosition)

            # merge two rows into the golden ROI key(if exist) in goldenROIDatas
            roiKey = confirmed_row[self.rowFormat.confirmedResultFormat['golden-position']].replace(" ", "")
            roiLabeledInGolden = self.getGoldenLabelByCoordinate(roiKey) # get golden roi answer
            mergedRowValue = {'inferenced-result-label' : inference_row[self.rowFormat.inferenceResultFormat['result-label-name']],
                              'confirmed-result-label'  : confirmed_row[self.rowFormat.confirmedResultFormat['result-label-name']],
                              'golden-label'            : roiLabeledInGolden,
                              'inspect-left-top'        : inference_row[self.rowFormat.inferenceResultFormat['inspect-left-top']].replace(' ', ''),
                              'inspect-right-bottom'    : inference_row[self.rowFormat.inferenceResultFormat['inspect-right-bottom']].replace(' ', ''),
                              'duration'                : inference_row[self.rowFormat.inferenceResultFormat['duration']],
                              'inference-ok-ng'         : inference_row[self.rowFormat.inferenceResultFormat['ok-ng']],
                              'confirmed-ok-ng'         : confirmed_row[self.rowFormat.confirmedResultFormat['ok-ng']],
                              'confidence'              : inference_row[self.rowFormat.inferenceResultFormat['confidence']],
                              'inferenced-file-path'    : inferenceResultFilePath,
                              'confirmed-file-path'     : confirmedResultFilePath}
            self.__appendDataIntoDictionary(self.goldenROIResultDatas, roiKey, mergedRowValue)
            '''
            (confirmed result, inference result) = (OK, OK) => confidence can be used for calculate
            (confirmed result, inference result) = (OK, NG) => confidence cannot be used for calculate(means inference is overkill, the confidence is belongs to mis-classified class's confidence.)
            (confirmed result, inference result) = (NG, OK) => confidence cannot be used for calculate(means inference is leakage, the confidence is belongs to mis-classified class's confidence.) 
            (confirmed result, inference result) = (NG, NG) => only those confidence which confirmed and inference label are the same could be used for calculate.
            Which means only those lables are equal in confirmed and inference are include in calculation.
            '''
            if mergedRowValue['inferenced-result-label'] == mergedRowValue['confirmed-result-label']:
                self.__appendDataIntoDictionary(self.labelConfidenceDatas, mergedRowValue['confirmed-result-label'], float(mergedRowValue['confidence']))
        pass

    def __generateAIThreshold(self):
        filesInInferenceResultFolder = os.listdir(self.inferenceResultFolderPath)
        filesInConfirmedResultFolder = os.listdir(self.confirmedResultFolderPath)

        # check file is pairly exist.
        pairFileNameList = list(set(filesInInferenceResultFolder).intersection(set(filesInConfirmedResultFolder)))

        # parse golden label
        self.goldenLabelRowList.clear()
        self.goldenLabelRowList = self.__parseData(self.goldenLabelFilePath, ';')

        # parse and integrate two files into a single golden ROI based structure
        for fileName in pairFileNameList:
            self.__parseThenMerge(os.path.join(self.inferenceResultFolderPath, fileName), os.path.join(self.confirmedResultFolderPath, fileName))
        
        # find each label's maximum and minimum confidence
        for label in list(self.labelConfidenceDatas):
            maxConfidence = max(self.labelConfidenceDatas[label])
            minConfidence = min(self.labelConfidenceDatas[label])
            self.labelConfidenceMaxMinDatas[label] = {'max': maxConfidence, 'min': minConfidence}
            

        # for each golden ROI, select golden ROI's label relative threshold for recommand based on the objective
        self.__recommandThreshold.clear()
        for roi in list(self.goldenROIResultDatas):
            samples = self.goldenROIResultDatas[roi]
            left_top, right_bottom = self.saparate_left_top_right_bottom_coordinate_str(roi)
            goldenROI = left_top.replace(',', ', ') + ";" + right_bottom.replace(',', ', ')
            goldenLabel = self.getGoldenLabelByCoordinate(roi)
            if self.objective == 'preventLeakage':
                self.__recommandThreshold.append(goldenROI + ";" + str(self.labelConfidenceMaxMinDatas[goldenLabel]['max']))
            elif self.objective == 'preventOverkill':
                self.__recommandThreshold.append(goldenROI + ";" + str(self.labelConfidenceMaxMinDatas[goldenLabel]['min']))
            elif self.objective == 'preventLeakage-scale':
                self.__recommandThreshold.append(goldenROI + ";" + str(self.labelConfidenceMaxMinDatas[goldenLabel]['max'] * (1 + self.thresholdScale)))
            elif self.objective == 'preventOverkill-scale':
                self.__recommandThreshold.append(goldenROI + ";" + str(self.labelConfidenceMaxMinDatas[goldenLabel]['min'] * (1 - self.thresholdScale)))
            else:
                self.__recommandThreshold.append(goldenROI + ";" + str(0.9))

    def generate(self, targetMethod='DIP'):      
        """Implement the threshold generator algorithm based on different data and methodologies.

        Args:
            targetMethod (str, optional): DIP used threshold recommander interface. Defaults to 'DIP'.
        """        
        if targetMethod == 'DIP':
            self.goldenROIResultDatas.clear()
            self.__generateAIThreshold()
        else:
            self.__recommandThreshold = float('nan')
    
    def save(self, saveFilePath):
        with open(saveFilePath, 'w') as file:
            for row in self.ROIThresholds:
                file.write(row + '\n')

if __name__ == '__main__':
    import timeit
    Debug_WatchTime = False

    print('[Start illustrating ThresholdRecommander.]')
    inferenceResultFolderPath = r'/home/eva-2004/AAI/train/800/inspection/labels/inferenceResult'
    confirmedResultFolderPath = r'/home/eva-2004/AAI/train/800/inspection/labels/confirmedResult'
    goldenLabelFilePath = r'/home/eva-2004/AAI/train/800/labels/golden/golden.txt'

    # Instantiation ThresholdRecommander by required signatures.
    threasholdRecommander = ThresholdRecommander(inferenceResultFolderPath, confirmedResultFolderPath, goldenLabelFilePath, objective='preventLeakage')

    # Call its corresponding interface for execution.
    if Debug_WatchTime:
        # Measure the execution time in microseconds
        execution_time_seconds = timeit.timeit('threasholdRecommander.generate(\'DIP\')', globals=globals(), number=1000)
        print("Execution time: around ", (execution_time_seconds / 1000) * 1000, "milliseconds")
    else:
        threasholdRecommander.generate('DIP')
    

    # Get the threshold of each ROI in code.
    print(f'generated threshold = {threasholdRecommander.ROIThresholds}')

    # Save the reommand ROI threshold to file.
    saveROIRecommandThresholdPath = r'/home/eva-2004/AAI/train/800/golden-roi-threshold.txt'
    threasholdRecommander.save(saveROIRecommandThresholdPath)

    print('... <save recommand ROI recommand threshold done> ...')
    print('... <generate done> ...')